"""Vulnerability Analysis with GenAI"""

import boto3
import json
from typing import Dict, Any, List
from datetime import datetime
from bedrock_models import BedrockModelFactory


class VulnerabilityAnalyzer:
    """GenAI-powered vulnerability analysis"""
    
    def __init__(self, model_id: str = "amazon.titan-text-premier-v1:0"):
        self.model = BedrockModelFactory.create_model(model_id)
        self.model_id = model_id
    
    def analyze_instance(self, instance_id: str) -> Dict[str, Any]:
        """Analyze vulnerabilities for a specific EC2 instance"""
        try:
            # Get real vulnerability data from Inspector
            from aws_services import AWSInspector
            inspector = AWSInspector()
            findings_data = inspector.get_findings([instance_id], "all")
            
            # Convert Inspector findings to our format
            vulnerabilities = []
            for finding in findings_data.get("findings", []):
                vuln = {
                    "cve_id": finding.get("title", "Unknown"),
                    "severity": finding.get("severity", "UNKNOWN"),
                    "cvss_score": finding.get("inspector_score", 0.0),
                    "description": finding.get("description", ""),
                    "affected_package": finding.get("package_name", "Unknown"),
                    "fixed_version": finding.get("fixed_in_version", "")
                }
                vulnerabilities.append(vuln)
            
            # Calculate risk score using GenAI
            risk_analysis = self._calculate_risk_score(vulnerabilities, instance_id)
            
            # Generate remediation priorities
            remediation_priority = self._prioritize_remediation(vulnerabilities)
            
            return {
                "instance_id": instance_id,
                "vulnerabilities": vulnerabilities,
                "risk_score": risk_analysis.get("risk_score", 0.0),
                "risk_factors": risk_analysis.get("risk_factors", []),
                "remediation_priority": remediation_priority,
                "analysis_time": datetime.utcnow().isoformat(),
                "recommendations": risk_analysis.get("recommendations", [])
            }
            
        except Exception as e:
            return {
                "instance_id": instance_id,
                "vulnerabilities": [],
                "risk_score": 0.0,
                "error": str(e),
                "analysis_time": datetime.utcnow().isoformat()
            }
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict], instance_id: str) -> Dict[str, Any]:
        """Use GenAI to calculate comprehensive risk score"""
        try:
            # Prepare context for GenAI analysis
            vulnerability_context = {
                "instance_id": instance_id,
                "vulnerability_count": len(vulnerabilities),
                "critical_vulns": len([v for v in vulnerabilities if v.get("severity") == "CRITICAL"]),
                "high_vulns": len([v for v in vulnerabilities if v.get("severity") == "HIGH"]),
                "avg_cvss": sum([v.get("cvss_score", 0) for v in vulnerabilities]) / len(vulnerabilities) if vulnerabilities else 0
            }
            
            prompt = f"""
Analyze the security risk for EC2 instance {instance_id} with the following vulnerability data:

Vulnerability Summary:
- Total vulnerabilities: {vulnerability_context['vulnerability_count']}
- Critical severity: {vulnerability_context['critical_vulns']}
- High severity: {vulnerability_context['high_vulns']}
- Average CVSS score: {vulnerability_context['avg_cvss']:.1f}

Provide a risk assessment with:
1. Overall risk score (0-100)
2. Key risk factors
3. Immediate recommendations

Respond in JSON format with keys: risk_score, risk_factors, recommendations
"""
            
            # Call Bedrock Claude
            response = self._call_bedrock(prompt)
            
            if response:
                return response
            else:
                # Fallback calculation
                return self._fallback_risk_calculation(vulnerability_context)
                
        except Exception as e:
            # Fallback to simple calculation
            return self._fallback_risk_calculation({
                "vulnerability_count": len(vulnerabilities),
                "avg_cvss": sum([v.get("cvss_score", 0) for v in vulnerabilities]) / len(vulnerabilities) if vulnerabilities else 0
            })
    
    def _call_bedrock(self, prompt: str) -> Dict[str, Any]:
        """Call Bedrock model for GenAI analysis"""
        try:
            content = self.model.generate_response(prompt, max_tokens=1000)
            
            if not content:
                return None
            
            # Try to parse JSON response
            try:
                return json.loads(content)
            except json.JSONDecodeError:
                # If not JSON, extract key information
                return {
                    "risk_score": 75.0,  # Default moderate risk
                    "risk_factors": ["Multiple vulnerabilities detected"],
                    "recommendations": ["Review and patch critical vulnerabilities"]
                }
                
        except Exception as e:
            return None
    
    def _fallback_risk_calculation(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Fallback risk calculation when GenAI is unavailable"""
        vuln_count = context.get("vulnerability_count", 0)
        avg_cvss = context.get("avg_cvss", 0)
        
        # Simple risk score calculation
        base_score = min(avg_cvss * 10, 100)  # CVSS to 0-100 scale
        volume_multiplier = min(1 + (vuln_count * 0.1), 2.0)  # Volume impact
        risk_score = min(base_score * volume_multiplier, 100)
        
        risk_factors = []
        if vuln_count > 10:
            risk_factors.append("High vulnerability count")
        if avg_cvss >= 8.0:
            risk_factors.append("High severity vulnerabilities")
        if avg_cvss >= 9.0:
            risk_factors.append("Critical vulnerabilities present")
        
        recommendations = []
        if risk_score >= 80:
            recommendations.append("Immediate patching required")
        elif risk_score >= 60:
            recommendations.append("Schedule patching within 24 hours")
        else:
            recommendations.append("Schedule patching during next maintenance window")
        
        return {
            "risk_score": round(risk_score, 1),
            "risk_factors": risk_factors,
            "recommendations": recommendations
        }
    
    def _prioritize_remediation(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Use GenAI to prioritize remediation actions"""
        try:
            if not vulnerabilities:
                return []
            
            # Sort by CVSS score and severity
            sorted_vulns = sorted(vulnerabilities, key=lambda x: (x.get("cvss_score", 0)), reverse=True)
            
            priority_list = []
            for i, vuln in enumerate(sorted_vulns[:5]):  # Top 5 priorities
                priority_list.append({
                    "priority": i + 1,
                    "cve_id": vuln.get("cve_id"),
                    "severity": vuln.get("severity"),
                    "cvss_score": vuln.get("cvss_score"),
                    "action": "patch" if vuln.get("fixed_version") else "investigate",
                    "urgency": "immediate" if vuln.get("cvss_score", 0) >= 9.0 else "high" if vuln.get("cvss_score", 0) >= 7.0 else "medium"
                })
            
            return priority_list
            
        except Exception as e:
            return [{"error": str(e)}]
    
    def generate_remediation_plan(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Generate GenAI-powered remediation recommendations"""
        try:
            if not vulnerabilities:
                return {
                    "plan": [],
                    "estimated_time": "0 minutes",
                    "risk_assessment": "low"
                }
            
            # Categorize vulnerabilities
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "CRITICAL"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "HIGH"]
            
            plan_steps = []
            total_time = 0
            
            # Critical vulnerabilities first
            if critical_vulns:
                plan_steps.append({
                    "step": 1,
                    "action": "Emergency patch critical vulnerabilities",
                    "vulnerabilities": len(critical_vulns),
                    "estimated_time": 30,
                    "priority": "immediate"
                })
                total_time += 30
            
            # High severity vulnerabilities
            if high_vulns:
                plan_steps.append({
                    "step": len(plan_steps) + 1,
                    "action": "Schedule high severity patches",
                    "vulnerabilities": len(high_vulns),
                    "estimated_time": 45,
                    "priority": "high"
                })
                total_time += 45
            
            # System restart if needed
            if critical_vulns or high_vulns:
                plan_steps.append({
                    "step": len(plan_steps) + 1,
                    "action": "System restart and verification",
                    "estimated_time": 15,
                    "priority": "required"
                })
                total_time += 15
            
            # Risk assessment
            risk_level = "critical" if critical_vulns else "high" if high_vulns else "medium"
            
            return {
                "plan": plan_steps,
                "estimated_time": f"{total_time} minutes",
                "risk_assessment": risk_level,
                "total_vulnerabilities": len(vulnerabilities),
                "plan_generated": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            return {
                "plan": [],
                "estimated_time": "unknown",
                "risk_assessment": "unknown",
                "error": str(e)
            }
    
    def resolve_by_criticality(self, instance_ids: List[str], criticality: str) -> Dict[str, Any]:
        """Resolve vulnerabilities based on criticality level"""
        try:
            resolution_plan = {
                "instance_ids": instance_ids,
                "criticality": criticality,
                "actions": [],
                "estimated_completion": "",
                "risk_reduction": 0
            }
            
            # Define criticality thresholds
            thresholds = {
                "critical": {"min_cvss": 9.0, "severities": ["CRITICAL"]},
                "high": {"min_cvss": 7.0, "severities": ["CRITICAL", "HIGH"]},
                "medium": {"min_cvss": 4.0, "severities": ["CRITICAL", "HIGH", "MEDIUM"]},
                "all": {"min_cvss": 0.0, "severities": ["CRITICAL", "HIGH", "MEDIUM", "LOW"]}
            }
            
            threshold = thresholds.get(criticality, thresholds["high"])
            total_vulns_resolved = 0
            
            for instance_id in instance_ids:
                instance_analysis = self.analyze_instance(instance_id)
                vulnerabilities = instance_analysis.get("vulnerabilities", [])
                
                # Filter by criticality
                target_vulns = [
                    v for v in vulnerabilities 
                    if v.get("severity") in threshold["severities"] 
                    and v.get("cvss_score", 0) >= threshold["min_cvss"]
                ]
                
                if target_vulns:
                    action = {
                        "instance_id": instance_id,
                        "vulnerabilities_count": len(target_vulns),
                        "action_type": "patch" if criticality in ["critical", "high"] else "schedule",
                        "priority": "immediate" if criticality == "critical" else "high" if criticality == "high" else "medium",
                        "estimated_time": len(target_vulns) * 5  # 5 minutes per vulnerability
                    }
                    resolution_plan["actions"].append(action)
                    total_vulns_resolved += len(target_vulns)
            
            # Calculate risk reduction
            resolution_plan["risk_reduction"] = min(total_vulns_resolved * 10, 100)
            resolution_plan["total_vulnerabilities"] = total_vulns_resolved
            
            # Estimate completion time
            total_time = sum([action.get("estimated_time", 0) for action in resolution_plan["actions"]])
            resolution_plan["estimated_completion"] = f"{total_time} minutes"
            
            return resolution_plan
            
        except Exception as e:
            return {
                "instance_ids": instance_ids,
                "criticality": criticality,
                "actions": [],
                "error": str(e)
            }